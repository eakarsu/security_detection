import { Injectable } from '@nestjs/common';
import { SecurityNode } from '../interfaces/security-node.interface';

export interface VulnerabilityConfig {
  scanType: 'basic' | 'comprehensive' | 'critical_only';
  scanDepth: 'surface' | 'deep' | 'exhaustive';
  includeExploits: boolean;
  cvssThreshold: number;
  enableWebScan: boolean;
  enableNetworkScan: boolean;
  enableOSFingerprinting: boolean;
  enableServiceDetection: boolean;
  maxScanTime: number; // minutes
  concurrentScans: number;
}

export interface VulnerabilityInput {
  targets: Array<{
    type: 'ip' | 'hostname' | 'url' | 'cidr';
    value: string;
    ports?: number[];
    credentials?: {
      username: string;
      password: string;
      keyPath?: string;
    };
  }>;
  scanProfile?: string;
  excludeHosts?: string[];
  scanId?: string;
}

export interface VulnerabilityResult {
  scanId: string;
  scanStatus: 'running' | 'completed' | 'failed' | 'cancelled';
  startTime: Date;
  endTime?: Date;
  duration?: number; // seconds
  summary: {
    totalTargets: number;
    scannedTargets: number;
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    infoCount: number;
  };
  targets: Array<{
    target: string;
    status: 'scanned' | 'failed' | 'unreachable';
    osFingerprint?: {
      os: string;
      version: string;
      confidence: number;
    };
    openPorts: Array<{
      port: number;
      protocol: 'tcp' | 'udp';
      service: string;
      version?: string;
      state: 'open' | 'closed' | 'filtered';
    }>;
    vulnerabilities: Array<{
      id: string;
      cve?: string;
      title: string;
      description: string;
      severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
      cvssScore: number;
      cvssVector?: string;
      port?: number;
      service?: string;
      exploit?: {
        available: boolean;
        public: boolean;
        metasploit: boolean;
        references: string[];
      };
      solution: string;
      references: string[];
      firstDetected: Date;
      lastSeen: Date;
    }>;
    webVulnerabilities?: Array<{
      url: string;
      method: string;
      parameter?: string;
      vulnerability: string;
      severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
      description: string;
      payload?: string;
      recommendation: string;
    }>;
  }>;
  recommendations: string[];
  compliance: {
    pci_dss: { compliant: boolean; findings: string[] };
    iso27001: { compliant: boolean; findings: string[] };
    nist: { compliant: boolean; findings: string[] };
  };
  riskScore: number;
}

@Injectable()
export class VulnerabilityScannerNode extends SecurityNode {
  id = 'vulnerability-scanner';
  type = 'scanner';
  category = 'core' as const;
  name = 'Vulnerability Scanner';
  description = 'Comprehensive vulnerability assessment for networks, hosts, and web applications';
  version = '2.1.0';

  getSchema() {
    return {
      inputs: [
        {
          name: 'targets',
          type: 'array' as const,
          description: 'Targets to scan (IPs, hostnames, URLs, CIDR ranges)',
          required: true
        },
        {
          name: 'scan_profile',
          type: 'string' as const,
          description: 'Predefined scan profile to use',
          required: true
        }
      ],
      outputs: [
        {
          name: 'scan_results',
          type: 'object' as const,
          description: 'Comprehensive vulnerability scan results'
        },
        {
          name: 'vulnerability_count',
          type: 'number' as const,
          description: 'Total number of vulnerabilities found'
        },
        {
          name: 'risk_score',
          type: 'number' as const,
          description: 'Overall risk score (0-100)'
        },
        {
          name: 'critical_vulns',
          type: 'array' as const,
          description: 'List of critical vulnerabilities'
        }
      ],
      config: [
        {
          name: 'scanType',
          type: 'select' as const,
          required: false,
          default: 'comprehensive',
          options: ['basic', 'comprehensive', 'critical_only'],
          description: 'Type of vulnerability scan to perform'
        },
        {
          name: 'scanDepth',
          type: 'select' as const,
          required: false,
          default: 'deep',
          options: ['surface', 'deep', 'exhaustive'],
          description: 'Depth of scanning to perform'
        },
        {
          name: 'includeExploits',
          type: 'boolean' as const,
          required: false,
          default: true,
          description: 'Include exploit information in results'
        },
        {
          name: 'cvssThreshold',
          type: 'number' as const,
          required: false,
          default: 0.0,
          description: 'Minimum CVSS score to report (0.0-10.0)'
        },
        {
          name: 'enableWebScan',
          type: 'boolean' as const,
          required: false,
          default: true,
          description: 'Enable web application vulnerability scanning'
        },
        {
          name: 'enableNetworkScan',
          type: 'boolean' as const,
          required: false,
          default: true,
          description: 'Enable network vulnerability scanning'
        },
        {
          name: 'enableOSFingerprinting',
          type: 'boolean' as const,
          required: false,
          default: true,
          description: 'Enable operating system fingerprinting'
        },
        {
          name: 'enableServiceDetection',
          type: 'boolean' as const,
          required: false,
          default: true,
          description: 'Enable service version detection'
        },
        {
          name: 'maxScanTime',
          type: 'number' as const,
          required: false,
          default: 60,
          description: 'Maximum scan time in minutes'
        },
        {
          name: 'concurrentScans',
          type: 'number' as const,
          required: false,
          default: 5,
          description: 'Number of concurrent scans to run'
        }
      ]
    };
  }

  async execute(input: VulnerabilityInput, config: VulnerabilityConfig): Promise<VulnerabilityResult> {
    const scanId = input.scanId || `vuln_scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = new Date();
    
    try {
      console.log(`Starting vulnerability scan ${scanId} for ${input.targets.length} targets`);
      
      // Initialize scan result
      const result: VulnerabilityResult = {
        scanId,
        scanStatus: 'running',
        startTime,
        summary: {
          totalTargets: input.targets.length,
          scannedTargets: 0,
          totalVulnerabilities: 0,
          criticalCount: 0,
          highCount: 0,
          mediumCount: 0,
          lowCount: 0,
          infoCount: 0
        },
        targets: [],
        recommendations: [],
        compliance: {
          pci_dss: { compliant: true, findings: [] },
          iso27001: { compliant: true, findings: [] },
          nist: { compliant: true, findings: [] }
        },
        riskScore: 0
      };

      // Process each target
      for (const target of input.targets) {
        if (input.excludeHosts?.includes(target.value)) {
          console.log(`Skipping excluded host: ${target.value}`);
          continue;
        }

        const targetResult = await this.scanTarget(target, config);
        result.targets.push(targetResult);
        result.summary.scannedTargets++;

        // Update vulnerability counts
        targetResult.vulnerabilities.forEach(vuln => {
          result.summary.totalVulnerabilities++;
          switch (vuln.severity) {
            case 'critical': result.summary.criticalCount++; break;
            case 'high': result.summary.highCount++; break;
            case 'medium': result.summary.mediumCount++; break;
            case 'low': result.summary.lowCount++; break;
            case 'info': result.summary.infoCount++; break;
          }
        });
      }

      // Calculate risk score and compliance
      result.riskScore = this.calculateRiskScore(result);
      result.compliance = this.assessCompliance(result);
      result.recommendations = this.generateRecommendations(result);

      // Finalize scan
      result.endTime = new Date();
      result.duration = Math.round((result.endTime.getTime() - startTime.getTime()) / 1000);
      result.scanStatus = 'completed';

      console.log(`Vulnerability scan ${scanId} completed. Found ${result.summary.totalVulnerabilities} vulnerabilities.`);
      
      return result;

    } catch (error) {
      console.error(`Vulnerability scan ${scanId} failed:`, error);
      return {
        ...result,
        scanStatus: 'failed',
        endTime: new Date()
      } as VulnerabilityResult;
    }
  }

  private async scanTarget(target: VulnerabilityInput['targets'][0], config: VulnerabilityConfig) {
    console.log(`Scanning target: ${target.value} (${target.type})`);
    
    const targetResult = {
      target: target.value,
      status: 'scanned' as const,
      openPorts: [],
      vulnerabilities: [],
      webVulnerabilities: []
    };

    // 1. Port Scanning and Service Detection
    if (config.enableNetworkScan) {
      targetResult.openPorts = await this.performPortScan(target, config);
    }

    // 2. OS Fingerprinting
    if (config.enableOSFingerprinting) {
      (targetResult as any).osFingerprint = await this.performOSFingerprinting(target);
    }

    // 3. Network Vulnerability Scanning
    if (config.enableNetworkScan) {
      const networkVulns = await this.scanNetworkVulnerabilities(target, targetResult.openPorts, config);
      targetResult.vulnerabilities.push(...networkVulns);
    }

    // 4. Web Application Scanning
    if (config.enableWebScan && (target.type === 'url' || targetResult.openPorts.some(p => [80, 443, 8080, 8443].includes(p.port)))) {
      targetResult.webVulnerabilities = await this.scanWebVulnerabilities(target, config);
    }

    return targetResult;
  }

  private async performPortScan(target: VulnerabilityInput['targets'][0], config: VulnerabilityConfig) {
    // Simulate port scanning
    const commonPorts = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 1433, 3306, 3389, 5432, 6379, 27017];
    const portsToScan = target.ports || commonPorts;
    
    return portsToScan
      .filter(() => Math.random() > 0.7) // Simulate some ports being open
      .map(port => ({
        port,
        protocol: 'tcp' as const,
        service: this.identifyService(port),
        version: `${Math.floor(Math.random() * 5) + 1}.${Math.floor(Math.random() * 10)}`,
        state: 'open' as const
      }));
  }

  private async performOSFingerprinting(target: VulnerabilityInput['targets'][0]) {
    // Simulate OS fingerprinting
    const operatingSystems = [
      { os: 'Ubuntu Linux', version: '20.04', confidence: 95 },
      { os: 'Windows Server', version: '2019', confidence: 90 },
      { os: 'CentOS', version: '8', confidence: 85 },
      { os: 'Windows', version: '10', confidence: 80 }
    ];
    
    return operatingSystems[Math.floor(Math.random() * operatingSystems.length)];
  }

  private async scanNetworkVulnerabilities(
    target: VulnerabilityInput['targets'][0], 
    openPorts: any[], 
    config: VulnerabilityConfig
  ) {
    const vulnerabilities = [];
    
    // Generate vulnerabilities based on open services
    for (const port of openPorts) {
      const serviceVulns = await this.getServiceVulnerabilities(port.service, port.version, config);
      vulnerabilities.push(...serviceVulns);
    }

    // Add some common network vulnerabilities
    if (Math.random() > 0.6) {
      vulnerabilities.push({
        id: `VULN-${Date.now()}-1`,
        cve: 'CVE-2021-44228',
        title: 'Apache Log4j Remote Code Execution',
        description: 'Apache Log4j2 vulnerable to RCE via LDAP JNDI parsing',
        severity: 'critical' as const,
        cvssScore: 9.3,
        cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H',
        service: 'java-application',
        exploit: {
          available: true,
          public: true,
          metasploit: true,
          references: ['https://www.exploit-db.com/exploits/50592']
        },
        solution: 'Update Log4j to version 2.17.0 or later',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228'],
        firstDetected: new Date(),
        lastSeen: new Date()
      });
    }

    return vulnerabilities.filter(v => v.cvssScore >= config.cvssThreshold);
  }

  private async scanWebVulnerabilities(target: VulnerabilityInput['targets'][0], config: VulnerabilityConfig) {
    // Simulate web vulnerability scanning
    const webVulns = [];
    
    if (Math.random() > 0.5) {
      webVulns.push({
        url: `http://${target.value}/login`,
        method: 'POST',
        parameter: 'username',
        vulnerability: 'SQL Injection',
        severity: 'high' as const,
        description: 'SQL injection vulnerability in login form',
        payload: "' OR '1'='1",
        recommendation: 'Use parameterized queries and input validation'
      });
    }
    
    if (Math.random() > 0.7) {
      webVulns.push({
        url: `http://${target.value}/search`,
        method: 'GET',
        parameter: 'q',
        vulnerability: 'Cross-Site Scripting (XSS)',
        severity: 'medium' as const,
        description: 'Reflected XSS in search parameter',
        payload: '<script>alert("XSS")</script>',
        recommendation: 'Implement proper output encoding and Content Security Policy'
      });
    }

    return webVulns;
  }

  private async getServiceVulnerabilities(service: string, version: string, config: VulnerabilityConfig) {
    // Simulate service-specific vulnerability lookup
    const vulnerabilities = [];
    
    if (service === 'ssh' && Math.random() > 0.8) {
      vulnerabilities.push({
        id: `SSH-VULN-${Date.now()}`,
        title: 'SSH Weak Encryption Algorithms',
        description: 'SSH server supports weak encryption algorithms',
        severity: 'medium' as const,
        cvssScore: 5.3,
        service: 'ssh',
        solution: 'Disable weak ciphers in SSH configuration',
        references: ['https://www.ssh.com/academy/ssh/cipher'],
        firstDetected: new Date(),
        lastSeen: new Date()
      });
    }

    if (service === 'http' && Math.random() > 0.6) {
      vulnerabilities.push({
        id: `HTTP-VULN-${Date.now()}`,
        title: 'Missing Security Headers',
        description: 'Web server missing critical security headers',
        severity: 'low' as const,
        cvssScore: 3.1,
        service: 'http',
        solution: 'Implement security headers (HSTS, CSP, X-Frame-Options)',
        references: ['https://owasp.org/www-project-secure-headers/'],
        firstDetected: new Date(),
        lastSeen: new Date()
      });
    }

    return vulnerabilities;
  }

  private identifyService(port: number): string {
    const serviceMap: Record<number, string> = {
      21: 'ftp',
      22: 'ssh',
      23: 'telnet',
      25: 'smtp',
      53: 'dns',
      80: 'http',
      110: 'pop3',
      143: 'imap',
      443: 'https',
      993: 'imaps',
      995: 'pop3s',
      1433: 'mssql',
      3306: 'mysql',
      3389: 'rdp',
      5432: 'postgresql',
      6379: 'redis',
      27017: 'mongodb'
    };
    
    return serviceMap[port] || 'unknown';
  }

  private calculateRiskScore(result: VulnerabilityResult): number {
    let score = 0;
    
    // Weight vulnerabilities by severity
    score += result.summary.criticalCount * 25;
    score += result.summary.highCount * 15;
    score += result.summary.mediumCount * 8;
    score += result.summary.lowCount * 3;
    score += result.summary.infoCount * 1;
    
    // Factor in exploit availability
    result.targets.forEach(target => {
      target.vulnerabilities.forEach(vuln => {
        if (vuln.exploit?.available) {
          score += vuln.severity === 'critical' ? 10 : 5;
        }
      });
    });
    
    return Math.min(score, 100);
  }

  private assessCompliance(result: VulnerabilityResult) {
    const compliance = {
      pci_dss: { compliant: true, findings: [] as string[] },
      iso27001: { compliant: true, findings: [] as string[] },
      nist: { compliant: true, findings: [] as string[] }
    };

    // Check for compliance violations
    if (result.summary.criticalCount > 0) {
      const finding = `${result.summary.criticalCount} critical vulnerabilities found`;
      compliance.pci_dss.compliant = false;
      compliance.pci_dss.findings.push(finding);
      compliance.iso27001.compliant = false;
      compliance.iso27001.findings.push(finding);
      compliance.nist.compliant = false;
      compliance.nist.findings.push(finding);
    }

    return compliance;
  }

  private generateRecommendations(result: VulnerabilityResult): string[] {
    const recommendations = [];

    if (result.summary.criticalCount > 0) {
      recommendations.push('Immediately patch critical vulnerabilities');
      recommendations.push('Consider taking affected systems offline until patched');
    }

    if (result.summary.highCount > 5) {
      recommendations.push('Prioritize patching high-severity vulnerabilities');
    }

    if (result.riskScore > 50) {
      recommendations.push('Implement a vulnerability management program');
      recommendations.push('Schedule regular vulnerability assessments');
    }

    // Add service-specific recommendations
    result.targets.forEach(target => {
      if (target.openPorts.some(p => p.service === 'telnet')) {
        recommendations.push('Replace Telnet with SSH for secure remote access');
      }
      if (target.openPorts.some(p => p.service === 'ftp')) {
        recommendations.push('Consider using SFTP or FTPS instead of plain FTP');
      }
    });

    return [...new Set(recommendations)]; // Remove duplicates
  }

  configure(config: Partial<VulnerabilityConfig>) {
    const errors: string[] = [];
    
    if (config.cvssThreshold !== undefined && (config.cvssThreshold < 0 || config.cvssThreshold > 10)) {
      errors.push('cvssThreshold must be between 0.0 and 10.0');
    }
    
    if (config.maxScanTime !== undefined && config.maxScanTime < 1) {
      errors.push('maxScanTime must be at least 1 minute');
    }
    
    if (config.concurrentScans !== undefined && (config.concurrentScans < 1 || config.concurrentScans > 20)) {
      errors.push('concurrentScans must be between 1 and 20');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }
}